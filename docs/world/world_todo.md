QMTL 전략 상태 관리 아키텍처 설계 초안

개요 (Overview)

QMTL 시스템에서 전략 제출 후 “검증→운영” 전환의 전략 생애주기 관리 구조를 설계한다. 목표는 새로운 전략이 충분한 모의 검증을 거쳐 유효성이 입증된 경우에만 실제 거래를 수행하도록 하는 것이다. 이를 위해 월드(World) 단위로 전략 상태를 관리하고, 성과 지표 기반의 평가 정책에 따라 자동으로 상태를 전환한다. 본 설계는 초기 구상 단계로, 구조적 명확성, 유연한 조건 설정, 확장성을 모두 고려한다. (과거의 `--mode` 및 `backtest/dry-run/live` API는 제거되었으며, 실행은 항상 WS 결정과 활성 이벤트를 따르는 `Runner.run(world_id=..., gateway_url=...)` 또는 로컬 `Runner.offline(...)`을 사용한다.)
	•	월드(World): 다수의 전략을 담는 포트폴리오 환경 또는 전략 그룹을 의미한다. 각 월드는 자체 평가 정책(WorldPolicy)을 갖고 전략들의 상태 전환을 관리한다.
	•	전략(Strategy): 사용자가 제출한 거래 전략 단위. 각 전략은 제출 후 검증(오프라인/시뮬레이션)과 운영(WS 활성 게이트 하 주문 허용) 단계를 거친다.
	•	노드(Node): 전략을 구성하는 DAG 연산 단위이다. 노드는 데이터 입력, 처리, 매매 실행 등의 역할을 하며, 전략의 실행 모드 및 데이터 충족 여부에 따라 상태가 달라진다.

이 문서에서는 노드, 전략, 월드의 상태 정의, 월드별 성과 평가 정책 구조, CLI/API 인터페이스 설계, 상태 자동 전환 흐름, 시스템 구현을 위한 확장사항 및 구현 작업 목록을 체계적으로 정리한다.

상태 정의 (States for Nodes, Strategies, Worlds)

전략 실행과 관리에는 여러 수준의 상태 개념이 있다. 노드 상태는 데이터 준비 및 실행 여부를, 전략 상태는 해당 전략의 생애주기 단계를, 월드 상태는 월드 환경의 동작 모드를 나타낸다. 각 상태를 명확히 정의하여 FSM(Finite State Machine)으로 관리함으로써 전략의 상태 흐름을 엄격하고 직관적으로 제어한다 ￼. 주요 상태는 다음과 같다.

노드 상태 (Node States)
	•	초기화 (Initialized): 노드가 생성되었지만 아직 실행 전인 상태. 필요 리소스 할당 및 초기 구독 설정 단계.
	•	준비중 (Pre-Warmup): 노드의 입력 데이터가 **설정된 기간(period)**만큼 쌓이기 전까지의 대기 상태이다. 이 기간 동안 노드는 출력을 생성하지 않으며, 필요한 데이터 누적을 기다린다 (예: 60초 간격, 30개 period 설정 시 약 30분간 데이터 축적 전까지) ￼ ￼. Pre-warmup 상태를 명시적으로 표기하여 초기 단계에서의 미완전한 데이터를 구분한다.
	•	실행중 (Active): 노드가 필요한 데이터 요건을 충족하고 정상적으로 연산을 수행 중인 상태. 실시간 데이터 스트림 처리나 백테스트 데이터 연산을 통해 결과를 생성한다.
	•	완료 (Completed): 유한한 데이터 구간(오프라인 검증 등)에 대해 실행되는 노드의 연산이 종료된 상태. 모든 입력 구간을 처리하여 결과 출력을 완료했다. (실시간 환경에서는 일반적으로 Active 유지)
	•	오류 (Error): 노드 실행 중 예외나 오류가 발생하여 중단된 상태. 이 상태에서는 상위 전략에도 오류 플래그를 전달하며 필요 시 재시작이나 종료 조치가 취해진다.

노드 Pre-Warmup 예시: 어떤 노드가 1분봉(interval=60s) 데이터와 30개의 period를 요구하면, 최소 30분 분량의 데이터가 들어오기 전까지 해당 노드는 ‘pre-warmup’ 상태에 머물러 연산을 유보한다 ￼. 이는 초기 데이터 부족으로 인한 잘못된 신호 발생을 막고 일관성을 보장하기 위한 것이다 ￼.

전략 상태 (Strategy States)
	•	등록됨/초기 (Submitted/Initialized): 전략이 시스템에 제출되어 등록은 되었으나 아직 실행되지 않은 상태이다. (예: Gateway를 통해 DAG가 접수되고 실행 대기 중인 상태로, FSM 초기 상태인 ‘queued’에 대응)
	•	검증 실행중 (Validation/Simulation): 과거 데이터 재생이나 로컬 시뮬레이션(오프라인)으로 전략을 검증 중인 상태. 지정된 데이터 구간에 대해 전략의 DAG를 실행하여 성과 지표를 산출한다.
	•	운영(WS 관리 하) (Operational under WS): WS(WorldService) 결정과 활성 이벤트를 따르며 주문이 게이트된다. 활성 게이트가 OFF이거나 결정이 오래되어(stale) 신뢰할 수 없으면 주문은 차단되고 신호 계산만 수행된다.
	•	평가중 (Evaluating): 드라이런 실행 기간과 상당 부분 겹치는 개념으로, 평가 정책의 기준 충족 여부를 판정하고 있는 단계이다. 엄밀히는 상태라기보다 전략 승격 여부를 결정하는 프로세스를 나타낸다. 시스템이 드라이런 성과 데이터를 일정 주기마다 평가하여 조건 달성 시 실매매로의 상태 전이 이벤트를 발생시키므로, 드라이런 중인 기간은 곧 평가중인 기간으로 간주된다.
	•	라이브 실행중 (Live Trading Active): 전략이 실매매 활성화된 상태이다. 전략의 주문 노드가 실제 거래소/브로커 API와 연동되어 실시간으로 실제 주문을 발주하며, 실매매 손익이 계좌에 반영된다 ￼. Live 상태에서는 전략이 실시간으로 자율 실행되며, 지속적으로 성과 모니터링을 받는다.
	•	비활성 (Inactive): 전략이 현재 어떠한 실행도 진행되고 있지 않은 상태이다. 예를 들어, 드라이런 또는 라이브 실행 후 수동 또는 자동 조치로 중단되어 대기 중인 경우나, 성능 저조로 활성 포트폴리오에서 제외된 경우를 포함한다. 비활성 상태에서는 해당 전략에 자원이 할당되지 않고, 필요 시 다시 활성화(dry-run 또는 live)하거나 폐기할 수 있다.
	•	종료/아카이브 (Archived): 전략이 더 이상 운영되지 않으며 과거 기록용으로만 보관되는 상태이다. (예: 사용자가 전략을 폐기하거나 월드에서 제거한 경우)

전략 상태 전이는 Finite State Machine으로 엄격히 관리되며, 이벤트에 따라 **초기 → 백테스트 → 드라이런(평가) → 라이브 → (비활성/종료)**의 흐름을 따른다. 특히, 매매 주문이 발생하는 전략은 바로 라이브로 가지 않고 드라이런 상태에서 일정 기간 운영하며 성과를 검증한 뒤, 정책 기준을 충족하면 실매매로 승격하는 것을 권장한다 ￼. 드라이런에서 라이브로의 전환은 수동으로도 가능하지만, 정책 기반 자동화되어 관리자가 일일이 개입하지 않아도 우수 전략만 자동 승격되도록 설계한다. 반대로 라이브 상태에서도 성과 악화 시 전략을 비활성화하거나 재평가 모드로 돌리는 (라이브→드라이런 또는 중지) 강등 전이가 정책에 의해 이루어질 수 있다 (히스테리시스 적용).

전략 상태 관리 예시: 한 전략 제출 시 과거 6개월간 백테스트를 수행하고 결과가 양호하면, 실시간 드라이런으로 1개월간 모니터링한다. 이 기간에 누적 수익률과 샤프비율 등이 월드 정책 임계치를 넘으면 자동으로 라이브 전환되어 실제 매매를 시작한다. 이후 라이브 운영 중 연속 손실로 성과 지표가 하락하면 정책에 따라 해당 전략을 비활성화하거나 다시 드라이런 모드로 격하하여 재검증할 수 있다. 이때 즉각적인 on/off로 인한 잦은 상태 변동을 막기 위해 히스테리시스 조건을 두어, 승격 기준보다 완화된 별도 강등 기준이 설정된다.

월드 상태 (World States)

월드는 전략들이 속한 환경의 단위로, 그 세계에서의 전략 운용 모드나 활성화 정도를 나타낸다. 월드별로 상태를 두어 전체 전략 동작 방식을 제어할 수 있다:
	•	운영중 (Active): 해당 월드가 정상 운영 상태로, 정책에 따라 전략들의 드라이런/라이브 전환이 활성화되어 있다. Active 상태의 월드에서는 정책 평가 스케줄러가 주기적으로 동작하며, 기준 충족 전략을 라이브로 승격시키고 부적합 전략을 비활성화하는 등 자동화 로직이 수행된다. 일반적인 운영 모드이다.
	•	평가전용 (Evaluation-Only): 월드가 실매매를 잠시 중지하고 모의 평가만 진행하는 상태이다. 이 모드에서는 모든 전략이 강제로 드라이런 모드로 동작하거나 신규 전략의 라이브 전환이 일시적으로 보류된다. 예를 들어 시장 급변 등으로 전체 전략에 대해 보호조치가 필요할 때나, 운영자 점검을 위해 일시적으로 실매매를 막고 싶을 때 사용한다. 평가전용 모드에서는 드라이런 데이터는 계속 축적되지만 실제 주문은 이루어지지 않는다.
	•	중단/비활성 (Paused): 월드 내 모든 전략 실행이 일시 정지된 상태이다. 스케줄러 및 전략 실행이 모두 중단되고, 새로운 상태 전이도 발생하지 않는다. 시스템 점검이나 오류 상황 시 월드를 통째로 멈추는 경우에 해당한다. Paused에서 Active로 재개하면 멈춘 지점부터 다시 평가 및 실행을 이어간다.
	•	종료 (Retired): 해당 월드가 사용 종료되어 더 이상 운영되지 않는 상태이다. 과거 기록은 조회 가능하나, 속한 전략들은 모두 종료되며 월드의 정책 평가도 수행되지 않는다.

(월드 상태는 시스템 운영적인 관점의 모드로, 주로 전체 전략에 대한 일괄 제어용이다. 일반적인 상황에서는 월드는 Active 상태이며 개별 전략들의 상태만 변동한다. 특별한 경우에만 월드 단위로 Evaluation-Only나 Paused를 활용한다.)

월드 성과 평가 정책 구조 (WorldPolicy)

각 월드는 WorldPolicy라는 성과 평가 정책을 가져서, 전략 승격/유지/강등 여부를 결정하는 기준들을 설정한다. WorldPolicy는 여러 지표 조건과 랭킹 요건을 조합하여 구성되며, 다음과 같은 요소들로 이루어진다:
	•	지표 임계값 (Metric Thresholds): 전략 성능을 평가하는 지표들과 임계값 조건의 집합. 예를 들어, 누적 수익률, 일간 PnL, Sharpe Ratio, 최대 낙폭 등의 지표에 대해 최소/최대 기준을 정한다. 정책은 “SharpeRatio >= 2.0 그리고 최대낙폭 <= -10%” 등의 다중 조건을 가질 수 있다. 각 지표 조건은 AND/OR 논리식으로 결합 가능하여, 복합적인 기준을 표현한다 (예: PnL > 5% AND Sharpe > 1.5 또는 월간 수익률 Top 10% 등). 지표는 드라이런 기간에 축적된 실현 손익 로그를 기반으로 산출되며, 백테스트 결과와 동일한 포맷으로 저장된 데이터를 사용한다 ￼.
	•	Top-K 제한 (Top-K Selection): 동시에 **라이브로 운용될 수 있는 전략의 최대 개수(K)**를 설정한다. 예를 들어 Top-5로 설정하면, 해당 월드에서는 성과 지표 기준 상위 5개의 전략만 실매매 활성 상태를 유지하고 나머지는 드라이런 또는 비활성 상태로 남는다. 이때 랭킹 산정 지표 (예: 월간 샤프비율 등)를 함께 정의하여 어떤 전략이 상위에 속하는지 결정한다. Top-K 정책은 자원 제한 또는 포트폴리오 관리 차원에서 사용되며, 동시에 활성화되는 전략 수를 관리하여 과도한 전략 난립을 방지한다.
	•	상관관계 제약 (Correlation Constraints): 전략들 간의 성과 상관도를 고려하여 유사한 전략의 동시 라이브를 제한한다. 예를 들어 동일 월드 내 두 전략의 수익률 시계열 상관계수가 0.9 이상으로 매우 높으면 둘을 모두 라이브 상태로 두지 않고 하나만 활성화하도록 정책화할 수 있다. 이 제약은 포트폴리오의 다양성 확보 및 리스크 분산을 위해 사용된다. 구현상, 시스템은 드라이런 단계에서 각 전략의 실현 손익 데이터를 누적하고, 일정 기간마다 상관계수를 계산하여 높은 상관 전략들을 서로 배타적인 그룹으로 묶는다. 정책에서는 각 그룹당 최대 활성 전략 수(예: 1개)를 설정하여, 한 그룹 내에서는 가장 성과가 좋은 전략만 라이브를 유지하고 나머지는 자동 비활성화한다.
	•	히스테리시스 (Hysteresis): 성과 조건의 임계값에 상승/하강 다른 기준을 적용하여 상태 변동에 완충작용을 준다. 예를 들어 수익률이 10%를 넘으면 라이브로 승격하지만, 라이브 상태에서 10% 밑으로 떨어졌다고 즉시 비활성화하지 않고 8% 미만으로 떨어질 때 비활성화하는 식으로 차이를 두어 임계값 주변의 잦은 온오프를 방지한다. 히스테리시스는 시간 지연 조건으로도 활용되어, 조건 충족 후 일정 기간 유지시 승격, 조건 미충족 후 일정 기간 지속시 강등 등으로 설정할 수 있다. 이를 통해 일시적인 변동에 전략이 흔들리지 않고 안정적인 상태 유지가 가능하도록 한다.
	•	조합 로직 (Policy Logic Composition): 위 조건들을 종합하여 최종 평가 판정 로직을 구성한다. WorldPolicy는 조건들을 AND/OR로 엮은 표현식 형태(예: (A AND B) OR (C) 형태)로 정의되거나, 정책 스크립트로 구현될 수 있다. 또한 각 조건에 가중치를 두어 점수화하고, 총점 기준으로 순위를 매겨 결정하는 등의 방식도 지원 가능하다. 설계 상 정책 표현은 **DSL(Domain Specific Language)**이나 구성 파일(YAML) 형태로 관리자가 쉽게 편집할 수 있게 하며, 새로운 지표나 조건이 추가되어도 확장 가능한 구조로 만든다.

평가 정책 설정 예시:
	•	임계값 조건: 4주 드라이런 결과 누적 수익률 ≥ 5%, 샤프비율 ≥ 1.5, 거래 빈도 20회 이상 AND 5분당 최대 손실 ≤ -0.5%.
	•	Top-K 제한: 상위 3개 전략만 라이브 허용, 순위 산정은 드라이런 기간 샤프비율 기준.
	•	상관 제약: 상관계수 0.8 이상으로 묶인 전략군은 한 번에 1개 전략만 라이브.
	•	히스테리시스: 승격 조건 충족 후 일주일간 유지되면 라이브 전환, 강등은 연속 3일간 지표 미달 시 시행.

위와 같은 WorldPolicy를 월드에 설정해두면, 시스템은 주어진 규칙에 따라 자동으로 전략들의 상태를 평가하고 변경한다. 정책 변경이 필요하면 월드 설정을 갱신하여 즉시 혹은 다음 평가 주기부터 반영한다.

인터페이스 설계 (World 설정 및 전략 활성화 제어)

관리자가 월드의 평가 정책을 구성/변경하고 특정 전략을 수동으로 활성/비활성 전환할 수 있는 인터페이스를 제공한다. 이는 CLI 명령어와 API 엔드포인트 두 가지 경로로 지원되며, 기존 QMTL Gateway의 관리 기능을 확장하여 구현한다. Gateway 컴포넌트는 FastAPI 기반의 HTTP API와 상태 관리 FSM을 이미 갖추고 있으므로 ￼, 이를 활용하여 월드/전략 제어용 인터페이스를 추가한다.
	•	월드 설정 CLI: qmtl world create <world_name>으로 새로운 월드를 생성하고, qmtl world policy set <world_name> --policy-file policy.yml 등의 명령으로 해당 월드의 평가 정책을 설정/변경할 수 있다. 정책 파일에는 앞서 정의한 임계값, Top-K, 상관 제약 등의 설정을 포함한다. 또한 qmtl world status <world_name> [--set <Active|Paused|EvalOnly>] 명령으로 월드의 운영 상태를 조회하거나 변경할 수 있다. 예를 들어 qmtl world status TradingWorld --set EvalOnly 명령으로 해당 월드를 평가전용 모드로 전환할 수 있다.
		•	전략 제어 CLI: 관리자는 개별 전략의 활성 게이트를 수동으로 토글할 수 있는 명령을 가진다. 예를 들어 qmtl world activation set <world_id> --strategy <strategy_id> --side long|short --active true|false 는 특정 전략/사이드의 주문 허용 상태를 강제로 전환한다. 수동 명령은 정책 자동화와 별개로 강제 개입 용도이므로, 시스템은 이를 이벤트로 인지하여 FSM 상태를 변경하되 이후 정책 스케줄에 의해 다시 변경될 수 있음을 경고한다. (강제 활성화했더라도 다음 평가 때 기준 미달이면 다시 비활성화될 수 있음)
	•	API 엔드포인트: 동일한 기능을 API로도 제공하여 외부 서비스나 UI에서 호출할 수 있게 한다. 예를 들어, POST /worlds/{world_id}/policy 엔드포인트로 JSON 형태의 정책을 제출하면 해당 월드의 WorldPolicy를 업데이트하고, POST /worlds/{world_id}/state로 월드 상태(Active/Paused 등)를 변경한다. 또한 POST /strategies/{strategy_id}/activate나 /deactivate 엔드포인트를 통해 전략 활성화/비활성화를 트리거한다. 각 API 호출 시 Gateway의 FSM 모듈을 통해 상태 변경 트랜잭션이 수행되며, 변경 내역은 DB에 기록되고 필요하면 관련 구성(예: 실행 스케줄러 등)에 반영된다.
	•	기존 Gateway 연계: Gateway는 DAG 제출 및 실행 관리 역할을 하고 있으므로, 새로운 월드/전략 제어 명령 역시 Gateway가 받아 처리한다. 예를 들어 qmtl strategy activate CLI 호출은 내부적으로 Gateway API를 호출하거나 Gateway의 CLI 서브커맨드로 구현되어, 중앙 상태 관리 로직을 통해 일관성 있게 처리된다. 이를 위해 Gateway api.py에 월드와 전략 상태 제어 관련 API 라우트를 추가하고, 해당 요청을 처리하는 서비스 로직을 구현한다. 해당 로직은 FSM을 통해 전략 상태를 업데이트하고 (예: “activate” 이벤트에 따라 ‘dry-run→live’ 상태 전이), Runner 실행을 트리거하거나 중단하는 역할을 수행한다.

인터페이스 설계에서는 접근 제어와 충돌 방지도 고려한다. 예를 들어, 이미 라이브 중인 전략에 대해 다시 activate 명령을 넣으면 에러를 응답하거나, 월드가 Paused 상태일 때 활성화 명령이 들어오면 대기시킨다. 이러한 검증을 CLI 단과 Gateway API 단에서 모두 수행하여 안정성을 높인다. 또한 상태 조회 명령 (qmtl world list, qmtl strategy list --world <id>) 등을 제공하여 현재 각 월드의 정책 설정과 전략들의 상태, 최근 성과 지표를 요약해서 볼 수 있도록 한다. 이는 운영자가 수동 개입 여부를 판단하거나 정책 튜닝 효과를 모니터링하는 데 도움이 된다.

전략 상태 자동화 흐름 및 평가 스케줄 (Automated Transition Flow)

위에서 정의한 상태와 정책을 기반으로, 전략 상태 전환을 자동화하는 흐름을 설계한다. 전체 프로세스는 전략 제출부터 실매매 활성화까지 단계적으로 진행되며, 각 단계에서 스케줄러 혹은 트리거에 의해 다음 단계로의 전환이 이루어진다. 주요 흐름은 다음과 같다:
	1.	전략 제출 및 초기 검증: 사용자가 새 전략을 제출하면 해당 전략은 우선 Initialized 상태로 등록된다. 시스템은 WorldService 정책에 따라 지정된 과거 기간에 대한 평가/검증(예: 최근 3개월 성과 산출)을 수행한다. 이 평가는 WS/Gateway 파이프라인에서 실행되며, Runner는 단일 진입점(`Runner.run(world_id=...)`)으로 실행되어 WS 결정/활성 상태를 따르기만 한다. 결과 지표(KPI)는 전략별 성과 DB에 기록된다.
	•	백테스트 결과가 치명적 결함(예: 논리 오류로 거래 불가, 과도한 손실 등)을 보여줄 경우 전략을 즉시 비활성(Rejected) 처리하고 흐름을 중단시킨다. 그렇지 않으면 다음 단계로 진행한다.
	2.	검증(Validate) 단계 시작: 검증 통과 조건을 만족하면 WS는 `effective_mode=validate`로 결정하며, Activation 게이팅은 기본 OFF(주문 차단)를 유지한다. Runner는 계속 `Runner.run(world_id=...)`로 동작하며, WS에서 오는 활성 이벤트를 반영해 주문 게이트 상태만 제어한다. 실시간 PnL/로그는 정책에 따라 수집되며, 평가 상태로 간주된다.
	3.	성과 데이터 수집 및 모니터링: 드라이런 상태의 전략들은 지속적으로 성과 지표가 기록된다. 시스템은 전략별 PnL, 수익률 곡선, 변동성, 거래 횟수 등의 데이터를 저장/갱신하며, 월드별로 이를 모아 관리한다. 성과 데이터에는 타임스탬프가 부여되어 일정 기간 단위(예: 일별, 주별)로 구분된 기록을 유지한다. 이렇게 수집된 데이터는 평가 정책에 명시된 지표 계산에 활용된다. (예: 드라이런 시작 후 7일간의 일일 손익으로 주간 수익률과 샤프 계산 등) 또한 각 전략의 상관관계 분석을 위해 해당 월드 내 다른 전략들의 데이터와 교차 계산도 수행한다.
	4.	정기 평가 스케줄러 실행: 별도의 **평가 스케줄러(배치 작업)**가 설정되어, 월드별로 정해진 주기마다 모든 활성 평가중 전략을 검사한다. 예를 들어 매일 자정 혹은 매주 월요일 00:00에 스케줄러가 동작하여, 지난 평가 시점 이후의 누적 데이터를 기준으로 WorldPolicy 조건 충족 여부를 판정한다. 스케줄러는 각 월드의 설정을 확인하여 평가 주기(evaluation interval)와 최소 드라이런 기간 등을 고려한 다음, 현재 드라이런 중인 전략들의 지표를 계산한다. 그런 다음 아래 알고리즘에 따라 상태를 전환한다:
	•	승격 대상 식별: 정책의 모든 기준을 충족하는 전략들을 찾는다. 단, Top-K 제한이 있을 경우 기준 충족 전략 중 성과 순위 상위 K까지만 승격 후보로 선정한다. 상관 제약이 있는 경우 유사 전략군 내에서 최고 성과 전략만 후보로 유지한다. 이 후보들에 대해 Min-Evaluation-Period(최소 평가기간)를 만족했는지도 확인한다 (예: 최소 2주간 드라이런 했는지). 모든 조건을 만족한 전략들을 승격 대상으로 확정한다.
	•	강등/비활성 대상 식별: 이미 라이브 상태인 전략들 중 정책 기준 대비 저조해진 전략을 찾는다. 예를 들어 라이브 상태에서 최근 4주 수익률이 정책 최소치에 못 미치거나 순위가 떨어져 Top-K 밖이 된 경우 등이 해당된다. 또한 상관관계 제약상 다른 더 나은 전략에 밀린 경우도 포함된다. 다만 히스테리시스 규칙에 따라 일시적 저조는 무시하고 추세적 저조만 선별한다 (예: 연속 3회 평가 주기 동안 기준 미달 등). 해당 전략들을 강등 후보로 식별한다.
	•	상태 전환 실행: 승격 대상 전략은 WS의 2‑Phase Apply로 활성 세트가 교체되며 주문 게이트가 ON으로 전환된다. Runner는 재기동 없이 `Runner.run(...)` 상태로 계속 동작하고, 활성 이벤트만 반영한다. 강등 시에는 게이트가 OFF로 전환되고 필요 시 포지션 정리 정책을 적용한다.
	•	동시성 및 예외 처리: 여러 전략이 동시에 승격될 때 Top-K 제한을 엄격히 적용하여 초과분은 승격 보류한다 (보류된 전략은 계속 드라이런 상태를 유지). 승격/강등 실행 중 오류가 발생하면 해당 전략만 건너뛰고 다른 전략 처리는 이어가며, 오류 내용은 로그로 기록하고 관리자가 확인할 수 있도록 한다. 스케줄러 작업은 원자적으로 이뤄지며, 상태 전환과 Runner 재시작 작업 간에는 트랜잭션 관리와 **락(LOCK)**을 걸어 일관성을 유지한다.
	5.	실매매 운영 및 지속 모니터링: 라이브로 전환된 전략은 실시간으로 운영되면서 지속적으로 모니터링된다. 월드의 평가 스케줄러는 라이브 전략도 포함하여 주기적인 재평가를 수행하며, 기준에 어긋나면 위에서 식별된 강등 로직에 따라 처리한다. 이로써 **전략 풀(pool)**이 동적으로 관리되어, 우수한 전략은 유지되고 저조한 전략은 퇴출되는 자율 운용 사이클이 완성된다. 운영자는 필요에 따라 수동으로 특정 전략을 비활성화하거나 (예: 외부 요인으로 전략 중지 필요 시) 정책을 조정할 수 있으며, 이러한 수동 개입도 FSM 이벤트로 기록되어 향후 평가에 참고된다.

위 자동화 흐름의 핵심은, 초기 드라이런에서 충분한 실계좌 모의 성과를 쌓은 후에만 전략을 실제 투자에 투입하는 것이다. 이는 QMTL 아키텍처 철학과 일치하며 (전략에 매매 트리거가 있으면 우선 dry-run으로 성과를 확인한 뒤 live로 전환 권장 ￼ ￼), 시스템 차원에서 이를 강제/자동화함으로써 리스크를 통제한다. 또한 정책을 통해 포트폴리오 전체 성과 최적화(Top-K, 분산투자)가 가능하도록 설계하였다.

시스템 구현 및 확장사항 (SDK/Runners/Brokerage Enhancements)

위 기능들을 실현하기 위해 QMTL의 기존 구조에 몇 가지 SDK 및 서비스 확장이 필요하다. 주요 구현 고려 사항은 다음과 같다:
	•	전략/월드 상태 모델 추가: 현재 Gateway의 상태 관리 FSM은 개별 전략 실행 요청의 진행 상태(queued, processing, completed 등) 위주로 설계되어 있다 ￼ ￼. 여기에 전략 라이프사이클 상태(Initialized, DryRun, Live 등)를 표현하는 FSM 또는 상태 필드를 추가해야 한다. 구체적으로 StrategyFSM을 확장하여 dry-run, live, inactive 등의 상태를 갖도록 하고, 이벤트로 PROMOTE, DEMOTE, PAUSE 등을 정의한다. 또는 별도의 StrategyLifecycleFSM을 두어, 기존 실행 FSM(Submit→Complete)과 병행 관리할 수도 있다. 상태는 Redis 캐시와 DB에 영속화하며, Redis 장애 시 DB로부터 복원 가능해야 한다 ￼. 월드 또한 상태(Active/Paused 등)를 가지므로, World 엔티티와 관련 상태 컬럼을 DB에 추가한다.
	•	World 엔티티 및 Policy 저장: 새로운 월드 개념을 도입하므로, 시스템 저장소에 월드 정보를 관리해야 한다. 이를 위해 World 테이블/컬렉션을 DB에 생성하고, 속성으로 월드 이름, 현재 상태(Active 등), 적용 중인 Policy 정의(직렬화된 JSON 또는 별도 테이블), 및 속한 전략 리스트(전략 ID 목록 또는 관계 테이블) 등을 저장한다. Policy는 JSON/YAML 형태로 저장하고 파싱하여 내부 객체(WorldPolicy)로 사용한다. World와 Strategy의 관계, Strategy별 현재 모드(드라이런/라이브) 및 소속 월드 등의 정보를 관리할 수 있도록 스키마 확장이 필요하다.
	•	성과 지표 수집 모듈: 드라이런 및 라이브 실행 시 전략의 PnL과 거래 로그를 수집·저장하는 모듈을 강화해야 한다. 현재 dry-run 모드에서 주문 로그와 PnL을 백테스트 포맷으로 저장하는 기능이 언급되어 있는데 ￼, 이를 구체화하여 실시간로깅/분석 서비스를 구성한다. 예를 들어, 각 전략별로 성과 기록용 Kafka 토픽이나 DB 테이블을 두어, Runner가 발생시키는 거래 이벤트(Order fill, PnL 업데이트)를 적재한다. 또는 SDK 내에 분석 유틸리티가 있다면 (로그를 파일이나 메모리에 쓰는 형태), Gateway가 해당 데이터를 요청하여 수집할 수 있게 한다. 나아가 이러한 데이터로부터 Sharpe, Max Drawdown 등의 KPI를 계산하는 함수를 구현하거나, Pandas 등의 라이브러리를 활용한 분석 스크립트를 SDK에 포함시켜 정책 평가 시 자동 호출되도록 한다.
	•	평가 엔진 및 스케줄러 구현: WorldPolicy에 따라 전략을 평가하는 **엔진(평가 서비스)**를 구현한다. 이는 입력으로 월드ID를 받아, 해당 월드의 정책과 전략 데이터를 불러와 조건 판정을 수행하는 모듈이다. Gateway의 백그라운드 워커(gateway/worker.py 등)에 이 로직을 포함하거나, 별도 서비스로 작성할 수 있다. Python 스케줄러 (e.g., APScheduler)나 Crontab 등을 활용하여 정기적으로 평가 엔진을 실행하며, 정책 주기에 맞춰 월드별 평가 작업을 등록한다. 평가 엔진은 각 전략별로 필요한 지표를 계산하고 정책식을 적용하여 승격/강등 대상 리스트를 반환한다. 그런 다음 Gateway(FSM)를 통해 해당 전략들에 대한 상태 전환 이벤트(PROMOTE/DEMOTE 등)를 발생시킨다. 이 과정에서 발생하는 일련의 상태 변경은 원자적 트랜잭션으로 처리하고, 중간에 누락이 없도록 해야 한다. 또한 스케줄 주기 이외에도, 수동 트리거 (예: 관리자가 즉시 평가 실행 버튼을 누르는 경우)를 위한 API도 제공한다.
	•	Runner 및 실행 제어 확장: Runner 클래스는 현재 backtest, dryrun, live 정적 메서드로 다른 모드를 실행할 수 있다 ￼. 상태 전환 자동화에서는 동일 전략에 대해 연속적인 실행 모드 전환이 필요하므로, Runner를 제어하는 상위 레벨의 실행 관리자가 요구된다. 예를 들어, 하나의 전략에 대해 백테스트 완료 후 동일한 전략 인스턴스를 드라이런으로 이어 실행하려면, **전략 상태 및 캐시를 인계인수(hand-off)**하는 메커니즘이 필요할 수 있다. 단순 구현으로는 백테스트와 실시간 실행은 별개 프로세스로 취급하므로, 백테스트 종료 시 결과만 저장하고 실시간 드라이런은 새 프로세스로 시작한다. 이 경우 초기 warm-up 문제를 해결하기 위해, 백테스트의 최종 상태(예: 지표 노드들의 캐시)를 저장해두었다가 드라이런 시작 시 불러오는 기능을 고려할 수 있다. (초기 구현 난이도를 감안하여, 첫 버전에서는 백테스트→드라이런 간 상태 인계를 생략하고 드라이런도 처음부터 다시 period 채우며 시작하도록 할 수 있다.) Runner 확장의 또 다른 측면은 동시 다중 실행 관리이다. 여러 전략이 병렬로 백그라운드 실행되므로, 이를 관리할 스레드/프로세스 풀이나 분산 환경 지원도 필요하다. Ray나 asyncio 기반으로 Runner가 실행되므로, Gateway 또는 별도 ExecutionManager가 각 전략 Runner 인스턴스를 관리(시작, 중지, 재시작)하고 상태를 모니터링하는 구조를 갖춘다.
	•	PaperTrading ↔ Brokerage 전환 처리: 드라이런과 라이브 모드 사이의 전환은 주문 처리 방식의 변경을 의미한다. QMTL은 Lean 엔진과 유사한 BrokerageModel 개념을 도입하고 있어, 주문 실행을 추상화하고 PaperTrading과 실제 Broker API를 쉽게 교체할 수 있도록 한다 ￼. 실제 구현에서는 주문 실행 노드나 Order Handler에서 현재 모드에 따라 주문 라우팅 경로를 다르게 한다. 예컨대, Order.execute() 호출 시 글로벌 설정의 mode를 참조하여, if mode == "dry-run": PaperBroker.execute(order) else: RealBroker.execute(order)와 같이 분기하거나, 전략 생성시 실행모드 플래그로 PaperTrading용 BrokerageModel 객체를 주입하는 식이다. 이미 요구사항에서 “dry-run 모드 선택 시 매매 노드를 모의 노드로 대체, live 모드 시 실제 브로커 거래 수행”이 명시되었으므로 ￼, 이를 지원하는 구조가 구현되어 있다. 본 설계에서는 런타임 모드 변경 시 이 교체가 문제없이 이뤄지도록 추가 조치를 한다. 구체적으로:
	•	전환 시 세션 처리: 드라이런 세션에서 모의 주문으로 존재하던 오더나 포지션은 라이브 전환 시 새로운 실제 계좌에서는 존재하지 않으므로, 상태 초기화 또는 포지션 이월 결정을 해야 한다. 일반적으로는 라이브 전환 시 새로운 주문 세션을 시작하도록 하며, 드라이런 단계의 포지션은 참고만 하고 실제로 시장에 동일 포지션을 잡지는 않는다 (시장 가격이 변동되었기 때문). 다만 운영자 선택에 따라 드라이런 종료 시점의 포트폴리오를 기반으로 시장가 청산 주문 또는 초기 진입 주문을 실행하여 드라이런 상태를 실계좌에 반영할 수도 있다. 이러한 옵션을 시스템에 제공할지 여부를 결정하고, 기본값은 포지션 비이월로 간주한다.
	•	기술 구현: PaperTrading 노드와 실제 Brokerage 노드는 공통 인터페이스를 구현하여, 전략 코드 상에서는 동일하게 주문 실행 함수를 호출하지만, 백엔드에서 바인딩된 구현체가 다르게 동작하게 한다. QMTL Brokerage 모듈에 이미 수수료, 슬리피지 등을 고려한 BrokerageModel이 정의되어 있다면, 이를 PaperBroker와 RealBroker로 구분 구현하고, Runner가 모드별로 적절한 객체를 주입하도록 수정한다. 또한 실매매 모드에서는 API 키, 계좌 정보 등 민감한 설정이 필요하므로, 월드별로 Broker 설정(예: 월드 A는 특정 거래소 API 키 사용)을 저장하고 라이브 전환 시 해당 정보를 적용하도록 한다.
	•	모니터링 및 알림 연계: 새로운 상태 전환 이벤트와 성과 평가 결과에 대해 모니터링 지표와 운영 알림을 추가한다. Prometheus 지표로 전략 수 (드라이런/라이브), 승격/강등 이벤트 건수, 평균 드라이런 기간 등을 수집하고, Grafana 대시보드에 월드별 현황을 시각화한다. 또한 중요한 상태 변화(예: 전략 X 라이브 전환, 전략 Y 비활성화)는 관리자에게 Slack/Email 등의 알림이 가도록 이벤트훅을 설정한다. 이러한 운영상의 편의는 추후 시스템 안정화와 사용자 신뢰 확보에 기여하므로, 설계 단계부터 함께 고려한다.

정리하면, QMTL의 SDK와 백엔드에 월드/정책/상태 관리 기능을 보강하여, 전략 제출부터 실매매까지의 과정을 자동화된 파이프라인으로 구축한다. 이 과정에서 기존 구조(예: Gateway FSM, Runner 모드, Brokerage 모델 등)를 최대한 활용하되, 새로운 개념(World, Policy)에 맞춰 확장하는 형태로 진행한다. 구현 초기에는 우선 단순한 방식(예: 상태 인계 없이 새 실행 시작, 보수적인 임계값 설정 등)으로 동작하게 한 뒤, 점진적으로 최적화와 부가기능(포지션 이월 옵션 등)을 추가한다.

초기 개념 정의 및 구현 작업 목록 (Concept Definitions & Task Breakdown)

마지막으로, 설계 초기 단계에서 필요한 핵심 개념 정의 정리와 실제 개발을 위한 작업 리스트를 제시한다. 이 목록은 구현 팀이 참고할 수 있는 단계별 가이드라인이다.

주요 개념 요약 (Terminology)
	•	World: 다중 전략 포트폴리오 환경. 전략 그룹 단위로 성과 평가 정책을 적용하고 상태 전환을 관리한다.
	•	Strategy State: 전략의 라이프사이클 상태 (Initialized, Backtesting, Dry-Run, Live, Inactive 등). FSM으로 관리되며 자동/수동 이벤트로 전이된다.
	•	Node State: 개별 노드의 실행 상태 (Pre-warmup, Active, Completed, Error 등). 데이터 의존 상태를 표시하며, 노드의 출력 생성 가능 여부를 나타낸다.
	•	WorldPolicy: 월드에 적용되는 전략 평가/운영 정책. 성과 지표 임계값, Top-K, 상관관계 제한, 히스테리시스 등의 조건 조합으로 구성되며, 어떤 전략을 라이브로 둘지 결정한다.
	•	Dry-Run vs Live Mode: 전략 실행 모드 구분으로, Dry-Run은 실시간 모의 투자 모드 (주문을 실행하지 않고 기록만)이고, Live는 실매매 모드(실제 브로커 API를 통한 거래)이다 ￼. 두 모드는 내부적으로 주문 처리 컴포넌트가 다르며, 전환 시 특별한 처리(주문 대체, 포지션 초기화 등)가 필요하다.
	•	Evaluation Scheduler: 월드 정책에 따라 주기적으로 전략들의 성과를 평가하고 상태 전환을 트리거하는 백그라운드 작업.
	•	FSM (Finite State Machine): 전략 및 월드 상태를 엄격히 관리하기 위한 상태 기계. 각 상태와 이벤트 전이를 정의하며, Redis/DB를 통해 내구성을 갖는다.

구현 작업 분해 (Tasks)
	1.	모델 정의 및 DB 스키마 확장: World 및 Strategy 상태를 표현하기 위한 ORM 모델/DB 테이블 추가. (worlds, strategies 테이블에 policy, state 필드 등).
	2.	FSM 상태/이벤트 추가: Gateway의 StrategyFSM에 DryRun, Live, Inactive 등의 상태와 Promote/Demote 이벤트 추가. 상태전이 규칙 정의 (예: DryRun + Promote -> Live, Live + Demote -> Inactive 등) 및 단위 테스트 작성.
	3.	WorldPolicy 파서 및 저장: 정책을 JSON/YAML로 정의하고 파싱하는 모듈 구현. 임계값, Top-K 등 스키마 정의 및 검증. Policy를 World 모델과 연동하여 저장/조회 API 제공.
	4.	CLI 명령 추가: qmtl CLI에 world 및 strategy 관련 서브커맨드 구현. (world create/set/list, strategy activate/deactivate/status 등) - CLI 파서와 호출 로직 개발, 도움말 문서화.
	5.	Gateway API 확장: FastAPI에 월드 생성/조회/갱신, 전략 상태 변경 엔드포인트 추가. 인증/권한 체크 및 입력 validation 포함. API 핸들러에서 FSM 및 DB 연동 로직 구현.
		6.	오프라인 검증 파이프라인: 전략 제출 시 자동으로 검증 작업을 큐잉해 실행하는 로직 구성. (예: Gateway 수신 -> task worker가 Runner.offline 호출 또는 Runner.run(..., offline=True)로 실행 -> 결과 저장). 실패 시 전략 상태 업데이트 처리.
	7.	실행 제어: 실행은 항상 `Runner.run(world_id=...)`로 시작되며, FSM Promote/Demote 이벤트에 따라 WS가 Activation을 업데이트한다. Runner는 활성 이벤트를 수신하여 게이트 상태만 전환한다. Execution Manager는 프로세스 생명주기와 모니터링만 담당한다.
	8.	성과 기록 및 지표 계산: 드라이런/라이브 실행 시 발생하는 주문 체결 이벤트를 포착하여 성과 DB나 로그에 기록하는 기능 추가. PnL, 수익률 등 계산 모듈 구현 및 검증. (예: 테스트로 가상 시나리오의 지표 계산 결과 확인)
	9.	평가 스케줄러 구현: 월드별로 전략 평가를 주기적으로 수행하는 스케줄러 개발. 각 주기마다 WorldPolicy 평가 엔진을 호출하고, 결과에 따라 Gateway에 상태변경 이벤트(PROMOTE/DEMOTE)를 전달. 멀티스레드/멀티프로세스 환경에서 안전하게 동작하도록 락이나 태스크 큐 활용.
	10.	승격/강등 로직 처리: FSM 이벤트 처리기 내에서 Promote 이벤트 시 WS 활성 게이트를 ON으로 전환하고, Demote 이벤트 시 OFF로 전환한다. 실행 자체는 항상 `Runner.run(world_id=...)`로 유지하며, 주문 허용 여부는 WS 활성 상태로 제어한다. 브로커 연결/차단은 활성 상태에 따라 수행한다.
	11.	BrokerageModel 적용: PaperTrading과 실제 Broker 전환을 쉽게 하기 위해 Brokerage 인터페이스 점검. 필요한 경우 PaperBroker, RealBroker 클래스를 구현하거나 기존 Lean BrokerageModel을 활용하여 모드별 분기처리 코드를 삽입. 실매매 모드에서의 예외 처리 (주문 거부 등)도 로그/재시도 전략 수립.
	12.	포지션 이월 옵션: (선택 구현) 드라이런→라이브 전환 시 모의 포지션을 실매매에 반영하는 옵션 개발. 구현 난이도 높으므로 기본은 미이월로 하고, 설정으로 켜면 드라이런 최종 잔고/포지션을 참조하여 라이브 시작 시 시장가 주문내는 기능.
	13.	테스트 및 시뮬레이션: 다양한 시나리오에 대한 테스트 작성. 예) 전략 하나의 백테스트→드라이런→승격 과정 통합 테스트, 다수 전략 Top-K 선별 테스트, 상관관계 제약 적용 테스트(가상 데이터로 상관계수 계산), 히스테리시스 시간 지연 테스트 등. 또한 스케줄러가 제대로 동시 전략들을 처리하는지에 대한 부하 테스트도 포함.
	14.	모니터링 대시보드 설정: Prometheus 지표 노출 (예: /metrics 엔드포인트에 전략 상태별 카운트, 승격 이벤트 카운트 등 추가), Grafana 대시보드 구성 JSON 작성. 평가 결과 요약, 월드별 활성전략 수 등의 시계열 그래프를 준비.
	15.	문서화 및 가이드: 개발자와 사용자용 문서 작성. 시스템 아키텍처 도식 (전략 상태 흐름 다이어그램 등), WorldPolicy 설정법 (예제 정책 파일), CLI/API 사용 예시, 운영상의 주의점(예: 정책 변경 시 바로 반영됨 안내) 등을 정리한 Architecture/Design 문서 및 User Guide를 업데이트한다. 또한 코드 주석과 README를 보강하고, 필요한 경우 FAQ 항목에 관련 질문을 추가한다.

以上의 작업들을 순차적으로 진행하며, 중간중간 코드 리뷰와 통합 테스트를 거쳐 품질을 확보한다. 설계 초기 단계에서는 우선 핵심 흐름(드라이런→라이브 자동전환)이 제대로 동작하는지에 초점을 맞추고, 이후 세부 최적화나 부가 기능을 추가하여 안정적이고 유연한 전략 상태 관리 시스템을 완성해 나간다.

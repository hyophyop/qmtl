"""Microprice and order-book imbalance indicators with priority weighting."""

from __future__ import annotations

from typing import Any, Iterable, Literal

from qmtl.runtime.sdk.cache_view import CacheView
from qmtl.runtime.sdk.node import Node

from .helpers import (
    best_order_book_level,
    extract_order_book_snapshot,
    sum_order_book_levels,
)

__all__ = ["microprice_imbalance", "conditional_entry_filter"]


def _compute_microprice(
    bid_price: float | None,
    bid_size: float | None,
    ask_price: float | None,
    ask_size: float | None,
    epsilon: float,
) -> float | None:
    """Return the microprice using top-of-book price and size information."""

    if bid_price is None or ask_price is None:
        return None

    bid_depth = bid_size or 0.0
    ask_depth = ask_size or 0.0

    denominator = bid_depth + ask_depth + epsilon
    if denominator == 0.0:
        return 0.0

    numerator = ask_price * bid_depth + bid_price * ask_depth
    return numerator / denominator


def microprice_imbalance(
    source: Node,
    *,
    top_levels: int = 1,
    epsilon: float = 1e-9,
    name: str | None = None,
) -> Node:
    """Return a node computing microprice and depth imbalance metrics.

    Parameters
    ----------
    source:
        Node yielding order-book snapshots containing ``"bids"`` and
        ``"asks"`` sequences. Each level may be a ``(price, size)`` pair, a
        mapping with ``price``/``size`` keys, or a raw size value.
    top_levels:
        Number of levels from each side included in the imbalance sum.
    epsilon:
        Small constant added to denominators to avoid division by zero.
    name:
        Optional node name. Defaults to ``"microprice_imbalance"``.
    """

    def compute(view: CacheView) -> dict[str, float | None] | None:
        snapshot = extract_order_book_snapshot(view, source)
        if snapshot is None:
            return None

        bids = snapshot.get("bids")
        asks = snapshot.get("asks")

        bid_price, bid_size = best_order_book_level(bids)
        ask_price, ask_size = best_order_book_level(asks)

        microprice = _compute_microprice(bid_price, bid_size, ask_price, ask_size, epsilon)

        bid_total = sum_order_book_levels(bids, top_levels)
        ask_total = sum_order_book_levels(asks, top_levels)

        if bid_total == 0.0 and ask_total == 0.0:
            imbalance = 0.0
        else:
            denominator = bid_total + ask_total + epsilon
            imbalance = (bid_total - ask_total) / denominator

        return {
            "microprice": microprice,
            "imbalance": imbalance,
        }

    return Node(
        input=source,
        compute_fn=compute,
        name=name or "microprice_imbalance",
        interval=source.interval,
        period=source.period,
    )


def _latest_value(view: CacheView, node: Node) -> Any:
    """Return the latest cached value for ``node`` or ``None`` when missing."""

    try:
        series = view[node][node.interval]
    except (KeyError, AttributeError, TypeError):
        return None

    latest = series.latest()
    if not latest:
        return None
    _, value = latest
    return value


def _iter_priority_values(value: Any) -> Iterable[float | None]:
    """Yield priority readings from scalar or iterable payloads."""

    if value is None:
        return []

    if isinstance(value, Iterable) and not isinstance(value, (str, bytes, bytearray)):
        return list(value)

    return [value]


def _within_bounds(value: float | None, bounds: tuple[float | None, float | None]) -> bool:
    """Return ``True`` when ``value`` lies within the provided bounds."""

    lower, upper = bounds
    if value is None:
        return False
    if lower is not None and value < lower:
        return False
    if upper is not None and value > upper:
        return False
    return True


def conditional_entry_filter(
    microprice_metrics: Node,
    priority_metric: Node,
    *,
    microprice_bounds: tuple[float | None, float | None] | None = None,
    imbalance_bounds: tuple[float | None, float | None] = (-0.25, 0.25),
    priority_bounds: tuple[float | None, float | None] = (0.5, 1.0),
    priority_mode: Literal["any", "all"] = "any",
    name: str | None = None,
) -> Node:
    """Return a node emitting a boolean gate for entry decisions.

    Parameters
    ----------
    microprice_metrics:
        Node generated by :func:`microprice_imbalance` (or equivalent) that
        exposes ``"microprice"`` and ``"imbalance"`` in its payload.
    priority_metric:
        Node produced by :func:`qmtl.runtime.indicators.priority_index` (or any
        other node emitting normalized queue priorities in ``[0, 1]``).
    microprice_bounds:
        Optional ``(min, max)`` tuple constraining the acceptable microprice
        range. When ``None`` the check only verifies that a microprice was
        computed.
    imbalance_bounds:
        ``(min, max)`` tuple constraining the order-book imbalance.
    priority_bounds:
        ``(min, max)`` tuple constraining the normalized priority index.
    priority_mode:
        When the upstream priority metric emits a sequence, choose whether
        **any** element or **all** elements must satisfy ``priority_bounds``.
    name:
        Optional node name. Defaults to ``"conditional_entry_filter"``.
    """

    normalized_priority_mode = priority_mode.lower()
    if normalized_priority_mode not in {"any", "all"}:
        raise ValueError("priority_mode must be either 'any' or 'all'")

    def compute(view: CacheView) -> bool:
        metrics = _latest_value(view, microprice_metrics)
        if not isinstance(metrics, dict):
            return False

        microprice_value = metrics.get("microprice")
        imbalance_value = metrics.get("imbalance")
        priority_value = _latest_value(view, priority_metric)

        if priority_value is None:
            return False

        if microprice_bounds is not None:
            if not _within_bounds(microprice_value, microprice_bounds):
                return False
        elif microprice_value is None:
            return False

        if not _within_bounds(imbalance_value, imbalance_bounds):
            return False

        priorities = [v for v in _iter_priority_values(priority_value) if v is not None]
        if not priorities:
            return False

        comparator = all if normalized_priority_mode == "all" else any
        return comparator(_within_bounds(p, priority_bounds) for p in priorities)

    if microprice_metrics.period and priority_metric.period:
        period = min(microprice_metrics.period, priority_metric.period)
    else:
        period = microprice_metrics.period or priority_metric.period

    return Node(
        input=[microprice_metrics, priority_metric],
        compute_fn=compute,
        name=name or "conditional_entry_filter",
        interval=microprice_metrics.interval,
        period=period,
    )
